{
  "Id": "14ffc4b7-1cab-4f81-a835-7da41fa47123",
  "Name": "GitHub - Push Yeoman Generator",
  "Description": "Clones a GitHub repo, runs Yeoman in the cloned directory, and pushes the changes. Note that the Yeoman generators can only use arguments or options, as prompts can not be provided.",
  "ActionType": "Octopus.Script",
  "Version": 1,
  "CommunityActionTemplateId": null,
  "Packages": [
    {
      "Id": "6bd0fbd2-442e-4ae9-9192-b93a041cfdd1",
      "Name": "YeomanGenerator",
      "AcquisitionLocation": "Server",
      "FeedId": null,
      "Properties": {
        "Extract": "True",
        "SelectionMode": "deferred",
        "PackageParameterName": "PopulateGithubRepo.Yeoman.Generator.Package",
        "Purpose": ""
      }
    }
  ],
  "Properties": {
    "Octopus.Action.RunOnServer": "true",
    "Octopus.Action.Script.ScriptSource": "Inline",
    "Octopus.Action.Script.Syntax": "Python",
    "Octopus.Action.Script.ScriptBody": "# This script forks a GitHub repo. It creates a token from a GitHub App installation to avoid\n# having to use a regular user account.\nimport subprocess\nimport sys\n\n# Install our own dependencies\nsubprocess.check_call([sys.executable, '-m', 'pip', 'install', 'jwt', '--disable-pip-version-check'])\nsubprocess.check_call([sys.executable, '-m', 'pip', 'install', 'requests', '--disable-pip-version-check'])\nsubprocess.check_call([sys.executable, '-m', 'pip', 'install', 'anyascii', '--disable-pip-version-check'])\n\nimport requests\nimport json\nimport subprocess\nimport sys\nimport os\nimport urllib.request\nimport base64\nimport re\nimport jwt\nimport time\nimport argparse\nimport platform\nimport zipfile\nimport lzma\nimport tarfile\nimport shutil\nimport urllib3\nfrom shlex import split\nfrom anyascii import anyascii\n\n# Disable insecure http request warnings\nurllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n\n# If this script is not being run as part of an Octopus step, setting variables is a noop\nif 'set_octopusvariable' not in globals():\n    def set_octopusvariable(variable, value):\n        pass\n\n# If this script is not being run as part of an Octopus step, return variables from environment variables.\n# Periods are replaced with underscores, and the variable name is converted to uppercase\nif \"get_octopusvariable\" not in globals():\n    def get_octopusvariable(variable):\n        return os.environ[re.sub('\\\\.', '_', variable.upper())]\n\n# If this script is not being run as part of an Octopus step, print directly to std out.\nif 'printverbose' not in globals():\n    def printverbose(msg):\n        print(msg)\n\n\ndef printverbose_noansi(output):\n    \"\"\"\n    Strip ANSI color codes and print the output as verbose\n    :param output: The output to print\n    \"\"\"\n    output_no_ansi = re.sub(r'\\x1b\\[[0-9;]*m', '', output)\n    printverbose(output_no_ansi)\n\n\ndef get_octopusvariable_quiet(variable):\n    \"\"\"\n    Gets an octopus variable, or an empty string if it does not exist.\n    :param variable: The variable name\n    :return: The variable value, or an empty string if the variable does not exist\n    \"\"\"\n    try:\n        return get_octopusvariable(variable)\n    except Exception as inst:\n        return ''\n\n\ndef execute(args, cwd=None, env=None, print_args=None, print_output=printverbose_noansi, raise_on_non_zero=False,\n            append_to_path=None):\n    \"\"\"\n        The execute method provides the ability to execute external processes while capturing and returning the\n        output to std err and std out and exit code.\n    \"\"\"\n\n    my_env = os.environ.copy() if env is None else env\n\n    if append_to_path is not None:\n        my_env[\"PATH\"] = append_to_path + os.pathsep + my_env['PATH']\n\n    process = subprocess.Popen(args,\n                               stdout=subprocess.PIPE,\n                               stderr=subprocess.PIPE,\n                               stdin=open(os.devnull),\n                               text=True,\n                               cwd=cwd,\n                               env=my_env)\n    stdout, stderr = process.communicate()\n    retcode = process.returncode\n\n    if not retcode == 0 and raise_on_non_zero:\n        raise Exception('command returned exit code ' + retcode)\n\n    if print_args is not None:\n        print_output(' '.join(args))\n\n    if print_output is not None:\n        print_output(stdout)\n        print_output(stderr)\n\n    return stdout, stderr, retcode\n\n\ndef init_argparse():\n    parser = argparse.ArgumentParser(\n        usage='%(prog)s [OPTION]',\n        description='Fork a GitHub repo'\n    )\n    parser.add_argument('--generator', action='store',\n                        default=get_octopusvariable_quiet(\n                            'PopulateGithubRepo.Yeoman.Generator.Name') or get_octopusvariable_quiet(\n                            'Yeoman.Generator.Name'))\n    parser.add_argument('--sub-generator', action='store',\n                        default=get_octopusvariable_quiet(\n                            'PopulateGithubRepo.Yeoman.Generator.SubGenerator') or get_octopusvariable_quiet(\n                            'Yeoman.Generator.SubGenerator'))\n    parser.add_argument('--generator-arguments', action='store',\n                        default=get_octopusvariable_quiet(\n                            'PopulateGithubRepo.Yeoman.Generator.Arguments') or get_octopusvariable_quiet(\n                            'Yeoman.Generator.Arguments'),\n                        help='The arguments to pas to yo. Pass all arguments as a single string. This string is then parsed as if it were yo arguments.')\n    parser.add_argument('--repo', action='store',\n                        default=get_octopusvariable_quiet(\n                            'PopulateGithubRepo.Git.Url.Repo') or get_octopusvariable_quiet(\n                            'Git.Url.Repo'))\n    parser.add_argument('--git-organization', action='store',\n                        default=get_octopusvariable_quiet(\n                            'PopulateGithubRepo.Git.Url.Organization') or get_octopusvariable_quiet(\n                            'Git.Url.Organization'))\n    parser.add_argument('--github-app-id', action='store',\n                        default=get_octopusvariable_quiet(\n                            'PopulateGithubRepo.GitHub.App.Id') or get_octopusvariable_quiet('GitHub.App.Id'))\n    parser.add_argument('--github-app-installation-id', action='store',\n                        default=get_octopusvariable_quiet(\n                            'PopulateGithubRepo.GitHub.App.InstallationId') or get_octopusvariable_quiet(\n                            'GitHub.App.InstallationId'))\n    parser.add_argument('--github-app-private-key', action='store',\n                        default=get_octopusvariable_quiet(\n                            'PopulateGithubRepo.GitHub.App.PrivateKey') or get_octopusvariable_quiet(\n                            'GitHub.App.PrivateKey'))\n    parser.add_argument('--git-password', action='store',\n                        default=get_octopusvariable_quiet(\n                            'PopulateGithubRepo.Git.Credentials.Password') or get_octopusvariable_quiet(\n                            'Git.Credentials.Password'),\n                        help='The git password. This takes precedence over the --github-app-id,  --github-app-installation-id, and --github-app-private-key')\n    parser.add_argument('--git-username', action='store',\n                        default=get_octopusvariable_quiet(\n                            'PopulateGithubRepo.Git.Credentials.Username') or get_octopusvariable_quiet(\n                            'Git.Credentials.Username'),\n                        help='The git username. This will be used for both the git authentication and the username associated with any commits.')\n\n    return parser.parse_known_args()\n\n\ndef generate_github_token(github_app_id, github_app_private_key, github_app_installation_id):\n    # Generate the tokens used by git and the GitHub API\n    app_id = github_app_id\n    signing_key = jwt.jwk_from_pem(github_app_private_key.encode('utf-8'))\n\n    payload = {\n        # Issued at time\n        'iat': int(time.time()),\n        # JWT expiration time (10 minutes maximum)\n        'exp': int(time.time()) + 600,\n        # GitHub App's identifier\n        'iss': app_id\n    }\n\n    # Create JWT\n    jwt_instance = jwt.JWT()\n    encoded_jwt = jwt_instance.encode(payload, signing_key, alg='RS256')\n\n    # Create access token\n    url = 'https://api.github.com/app/installations/' + github_app_installation_id + '/access_tokens'\n    headers = {\n        'Authorization': 'Bearer ' + encoded_jwt,\n        'Accept': 'application/vnd.github+json',\n        'X-GitHub-Api-Version': '2022-11-28'\n    }\n    request = urllib.request.Request(url, headers=headers, method='POST')\n    response = urllib.request.urlopen(request)\n    response_json = json.loads(response.read().decode())\n    return response_json['token']\n\n\ndef generate_auth_header(token):\n    auth = base64.b64encode(('x-access-token:' + token).encode('ascii'))\n    return 'Basic ' + auth.decode('ascii')\n\n\ndef verify_new_repo(token, cac_org, new_repo):\n    # Attempt to view the new repo\n    try:\n        url = 'https://api.github.com/repos/' + cac_org + '/' + new_repo\n        headers = {\n            'Accept': 'application/vnd.github+json',\n            'Authorization': 'Bearer ' + token,\n            'X-GitHub-Api-Version': '2022-11-28'\n        }\n        request = urllib.request.Request(url, headers=headers)\n        urllib.request.urlopen(request)\n        return True\n    except Exception as inst:\n        return False\n\n\ndef is_windows():\n    return platform.system() == 'Windows'\n\n\ndef download_file(url, filename, verify_ssl=True):\n    r = requests.get(url, verify=verify_ssl)\n    with open(filename, 'wb') as file:\n        file.write(r.content)\n\n\ndef ensure_git_exists():\n    if is_windows():\n        print(\"Checking git is installed\")\n        try:\n            stdout, _, exit_code = execute(['git', 'version'])\n            printverbose(stdout)\n            if not exit_code == 0:\n                raise \"git not found\"\n        except:\n            print(\"Downloading git\")\n            download_file('https://www.7-zip.org/a/7zr.exe', '7zr.exe')\n            download_file(\n                'https://github.com/git-for-windows/git/releases/download/v2.42.0.windows.2/PortableGit-2.42.0.2-64-bit.7z.exe',\n                'PortableGit.7z.exe')\n            print(\"Installing git\")\n            print(\"Consider installing git on the worker or using a standard worker-tools image\")\n            execute(['7zr.exe', 'x', 'PortableGit.7z.exe', '-o' + os.path.join(os.getcwd(), 'git'), '-y'])\n            return os.path.join(os.getcwd(), 'git', 'bin', 'git')\n\n    return 'git'\n\n\ndef install_npm_linux():\n    print(\"Downloading node\")\n    download_file(\n        'https://nodejs.org/dist/v18.18.2/node-v18.18.2-linux-x64.tar.xz',\n        'node.tar.xz')\n    print(\"Installing node on Linux\")\n    with lzma.open(\"node.tar.xz\", \"r\") as lzma_ref:\n        with open(\"node.tar\", \"wb\") as fdst:\n            shutil.copyfileobj(lzma_ref, fdst)\n    with tarfile.open(\"node.tar\", \"r\") as tar_ref:\n        tar_ref.extractall(os.getcwd())\n\n    try:\n        _, _, exit_code = execute([os.getcwd() + '/node-v18.18.2-linux-x64/bin/npm', '--version'],\n                                  append_to_path=os.getcwd() + '/node-v18.18.2-linux-x64/bin')\n        if not exit_code == 0:\n            raise Exception(\"Failed to run npm\")\n    except Exception as ex:\n        print('Failed to install npm ' + str(ex))\n        sys.exit(1)\n    return os.getcwd() + '/node-v18.18.2-linux-x64/bin/npm', os.getcwd() + '/node-v18.18.2-linux-x64/bin'\n\n\ndef install_npm_windows():\n    print(\"Downloading node\")\n    download_file('https://nodejs.org/dist/v18.18.2/node-v18.18.2-win-x64.zip', 'node.zip', False)\n    print(\"Installing node on Windows\")\n    with zipfile.ZipFile(\"node.zip\", \"r\") as zip_ref:\n        zip_ref.extractall(os.getcwd())\n    try:\n        _, _, exit_code = execute([os.path.join(os.getcwd(), 'node-v18.18.2-win-x64', 'npm.cmd'), '--version'],\n                                  append_to_path=os.path.join(os.getcwd(), 'node-v18.18.2-win-x64'))\n        if not exit_code == 0:\n            raise Exception(\"Failed to run npm\")\n    except Exception as ex:\n        print('Failed to install npm ' + str(ex))\n        sys.exit(1)\n\n    return (os.path.join(os.getcwd(), 'node-v18.18.2-win-x64', 'npm.cmd'),\n            os.path.join(os.getcwd(), 'node-v18.18.2-win-x64'))\n\n\ndef ensure_node_exists():\n    try:\n        print(\"Checking node is installed\")\n        _, _, exit_code = execute(['npm', '--version'])\n        if not exit_code == 0:\n            raise Exception(\"npm not found\")\n    except:\n        if is_windows():\n            return install_npm_windows()\n        else:\n            return install_npm_linux()\n\n    return 'npm', None\n\n\ndef ensure_yo_exists(npm_executable, npm_path):\n    try:\n        print(\"Checking Yeoman is installed\")\n        _, _, exit_code = execute(['yo', '--version'])\n        if not exit_code == 0:\n            raise Exception(\"yo not found\")\n    except:\n        print('Installing Yeoman')\n\n        _, _, retcode = execute([npm_executable, 'install', '-g', 'yo'], append_to_path=npm_path)\n\n        if not retcode == 0:\n            print(\"Failed to set install Yeoman. Check the verbose logs for details.\")\n            sys.exit(1)\n\n        npm_bin, _, retcode = execute([npm_executable, 'config', 'get', 'prefix'], append_to_path=npm_path)\n\n        if not retcode == 0:\n            print(\"Failed to set get the npm prefix directory. Check the verbose logs for details.\")\n            sys.exit(1)\n\n        try:\n            if is_windows():\n                _, _, exit_code = execute([os.path.join(npm_bin.strip(), 'yo.cmd'), '--version'],\n                                          append_to_path=npm_path)\n            else:\n                _, _, exit_code = execute([os.path.join(npm_bin.strip(), 'bin', 'yo'), '--version'],\n                                          append_to_path=npm_path)\n\n            if not exit_code == 0:\n                raise Exception(\"Failed to run yo\")\n        except Exception as ex:\n            print('Failed to install yo ' + str(ex))\n            sys.exit(1)\n\n        # Windows and Linux save NPM binaries in different directories\n        if is_windows():\n            return os.path.join(npm_bin.strip(), 'yo.cmd')\n\n        return os.path.join(npm_bin.strip(), 'bin', 'yo')\n\n    return 'yo'\n\n\ngit_executable = ensure_git_exists()\nnpm_executable, npm_path = ensure_node_exists()\nyo_executable = ensure_yo_exists(npm_executable, npm_path)\nparser, _ = init_argparse()\n\nif not parser.git_password.strip() and not (\n        parser.github_app_id.strip() and parser.github_app_private_key.strip() and parser.github_app_installation_id.strip()):\n    print(\"You must supply the GitHub token, or the GitHub App ID and private key and installation ID\")\n    sys.exit(1)\n\nif not parser.git_organization.strip():\n    print(\"You must define the organization\")\n    sys.exit(1)\n\nif not parser.repo.strip():\n    print(\"You must define the repo name\")\n    sys.exit(1)\n\nif not parser.generator.strip():\n    print(\"You must define the Yeoman generator\")\n    sys.exit(1)\n\n# Create a dir for the git clone\nif os.path.exists('downstream'):\n    shutil.rmtree('downstream')\n\nos.mkdir('downstream')\n\n# Create a dir for yeoman to use\nif os.path.exists('downstream-yeoman'):\n    shutil.rmtree('downstream-yeoman')\n\nos.mkdir('downstream-yeoman')\n# Yeoman will use a less privileged user to write to this directory, so grant full access\nif not is_windows():\n    os.chmod('downstream-yeoman', 0o777)\n\ndownstream_dir = os.path.join(os.getcwd(), 'downstream')\ndownstream_yeoman_dir = os.path.join(os.getcwd(), 'downstream-yeoman')\n\n# The access token is generated from a github app or supplied directly as an access token\ntoken = generate_github_token(parser.github_app_id, parser.github_app_private_key,\n                              parser.github_app_installation_id) if len(\n    parser.git_password.strip()) == 0 else parser.git_password.strip()\n\nif not verify_new_repo(token, parser.git_organization, parser.repo):\n    print('Repo at https://github.com/' + parser.git_organization + '/' + parser.repo + ' could not be accessed')\n    sys.exit(1)\n\n# We need to disable the credentials helper prompt, which will pop open a GUI prompt that we can never close\nif is_windows():\n    _, _, retcode = execute([git_executable, 'config', '--system', 'credential.helper', 'manager'])\n\n    if not retcode == 0:\n        print(\"Failed to set the credential.helper setting. Check the verbose logs for details.\")\n        sys.exit(1)\n\n    _, _, retcode = execute([git_executable, 'config', '--system', 'credential.modalprompt', 'false'])\n\n    if not retcode == 0:\n        print(\"Failed to srt the credential.modalprompt setting. Check the verbose logs for details.\")\n        sys.exit(1)\n\n    # We need to disable the credentials helper prompt, which will pop open a GUI prompt that we can never close\n    _, _, retcode = execute(\n        [git_executable, 'config', '--system', 'credential.microsoft.visualstudio.com.interactive', 'never'])\n\n    if not retcode == 0:\n        print(\n            \"Failed to set the credential.microsoft.visualstudio.com.interactive setting. Check the verbose logs for details.\")\n        sys.exit(1)\n\n_, _, retcode = execute([git_executable, 'config', '--global', 'user.email', 'octopus@octopus.com'])\n\nif not retcode == 0:\n    print(\"Failed to set the user.email setting. Check the verbose logs for details.\")\n    sys.exit(1)\n\n_, _, retcode = execute([git_executable, 'config', '--global', 'core.autocrlf', 'input'])\n\nif not retcode == 0:\n    print(\"Failed to set the core.autocrlf setting. Check the verbose logs for details.\")\n    sys.exit(1)\n\nusername = parser.git_username if len(parser.git_username) != 0 else 'Octopus'\n_, _, retcode = execute([git_executable, 'config', '--global', 'user.name', username])\n\nif not retcode == 0:\n    print(\"Failed to set the git username. Check the verbose logs for details.\")\n    sys.exit(1)\n\n_, _, retcode = execute([git_executable, 'config', '--global', 'credential.helper', 'cache'])\n\nif not retcode == 0:\n    print(\"Failed to set the git credential helper. Check the verbose logs for details.\")\n    sys.exit(1)\n\nprint('Cloning repo')\n\n_, _, retcode = execute(\n    [git_executable, 'clone',\n     'https://' + username + ':' + token + '@github.com/' + parser.git_organization + '/' + parser.repo + '.git',\n     'downstream'])\n\nif not retcode == 0:\n    print(\"Failed to clone the git repo. Check the verbose logs for details.\")\n    sys.exit(1)\n\nprint('Configuring Yeoman Generator')\n\n_, _, retcode = execute([npm_executable, 'install'], cwd=os.path.join(os.getcwd(), 'YeomanGenerator'), append_to_path=npm_path)\n\nif not retcode == 0:\n    print(\"Failed to install the generator dependencies. Check the verbose logs for details.\")\n    sys.exit(1)\n\n_, _, retcode = execute([npm_executable, 'link'], cwd=os.path.join(os.getcwd(), 'YeomanGenerator'), append_to_path=npm_path)\n\nif not retcode == 0:\n    print(\"Failed to link the npm module. Check the verbose logs for details.\")\n    sys.exit(1)\n\nprint('Running Yeoman Generator')\n\n# Treat the string of yo arguments as a raw input and parse it again. The resulting list of unknown arguments\n# is then passed to yo. We have to convert the incoming values from utf to ascii when parsing a second time.\nyo_args = split(anyascii(parser.generator_arguments))\n\ngenerator_name = parser.generator + ':' + parser.sub_generator if len(parser.sub_generator) != 0 else parser.generator\n\nyo_arguments = [yo_executable, generator_name, '--force', '--skip-install']\n\n# Yeoman has issues running as root, which it will often do in a container.\n# So we run Yeoman in its own directory, and then copy the changes to the git directory.\n_, _, retcode = execute(yo_arguments + yo_args, cwd=downstream_yeoman_dir, append_to_path=npm_path)\n\nif not retcode == 0:\n    print(\"Failed to run Yeoman. Check the verbose logs for details.\")\n    sys.exit(1)\n\nshutil.copytree(downstream_yeoman_dir, downstream_dir, dirs_exist_ok=True)\n\nprint('Adding changes to git')\n\n_, _, retcode = execute([git_executable, 'add', '.'], cwd=downstream_dir)\n\nif not retcode == 0:\n    print(\"Failed to add the git changes. Check the verbose logs for details.\")\n    sys.exit(1)\n\n# Check for pending changes\n_, _, retcode = execute([git_executable, 'diff-index', '--quiet', 'HEAD'], cwd=downstream_dir)\n\nif not retcode == 0:\n    print('Committing changes to git')\n    _, _, retcode = execute([git_executable, 'commit', '-m',\n                             'Added files from Yeoman generator ' + parser.generator + ':' + parser.sub_generator],\n                            cwd=downstream_dir)\n\n    if not retcode == 0:\n        print(\"Failed to set commit the git changes. Check the verbose logs for details.\")\n        sys.exit(1)\n\n    print('Pushing changes to git')\n\n    _, _, retcode = execute([git_executable, 'push', 'origin', 'main'], cwd=downstream_dir)\n\n    if not retcode == 0:\n        print(\"Failed to push the git changes. Check the verbose logs for details.\")\n        sys.exit(1)\n"
  },
  "Parameters": [
    {
      "Id": "334f5b32-01a8-4687-af33-54906e53cdee",
      "Name": "PopulateGithubRepo.Yeoman.Generator.Package",
      "Label": "Yeoman Generator Package",
      "HelpText": "The package containing the Yeoman package. Yeoman packages are usually distributed by npm, but they can also be packaged as zip files and pushed to the built-in feed or any other feed that supports zip files.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "Package"
      }
    },
    {
      "Id": "d1c9bf99-5f1f-417b-a482-a72878065871",
      "Name": "PopulateGithubRepo.Yeoman.Generator.Name",
      "Label": "Yeoman Generator Name",
      "HelpText": "The name of the Yeoman generator.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "2c1dd445-c1d4-4e44-91a0-b7f02682711b",
      "Name": "PopulateGithubRepo.Yeoman.Generator.SubGenerator",
      "Label": "Yeoman Subgenerator Name",
      "HelpText": "The optional name of the Yeoman subgenerator. Leave blank to use the default generator.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "bac9200a-2fce-4390-9b07-40e2a14c2e44",
      "Name": "PopulateGithubRepo.Yeoman.Generator.Arguments",
      "Label": "Yeoman Arguments",
      "HelpText": "The optional arguments pass to Yeoman to define options and arguments.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "f5c1092a-70d8-40ba-84e9-feedf5911946",
      "Name": "PopulateGithubRepo.Git.Url.Repo",
      "Label": "GitHub Repo Name",
      "HelpText": "The GitHub repo name i.e. `myrepo` in the URL`https://github.com/owner/myrepo`.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "ece2ee80-9572-4ca1-ab0a-65ffaec2edb7",
      "Name": "PopulateGithubRepo.Git.Url.Organization",
      "Label": "Github Owner",
      "HelpText": "The GitHub repo owner or organization i.e. `owner` in the URL `https://github.com/owner/myrepo`.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "4795ec27-f38b-4f2f-8417-97c3cd74d2db",
      "Name": "PopulateGithubRepo.Git.Credentials.Password",
      "Label": "GitHub Access Token",
      "HelpText": "The GitHub access token",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "300596fd-59b1-420e-b58f-305b7c83b54d",
      "Name": "PopulateGithubRepo.Git.Credentials.Username",
      "Label": "GitHub Username",
      "HelpText": "This will appear in the commit logs. Leave blank to use the default username.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    }
  ],
  "StepPackageId": "Octopus.Script",
  "$Meta": {
    "ExportedAt": "2023-10-16T23:49:40.031Z",
    "OctopusVersion": "2023.4.6093",
    "Type": "ActionTemplate"
  },
  "LastModifiedBy": "mcasperson",
  "Category": "github"
}

